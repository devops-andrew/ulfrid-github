---
title: '다시 Python3 정리'
date: '2019-06-13T17:54:32.169Z'
category: 'python'
---

![](./images/python.png)

# Boost your Python!!!

##이번 기회에 파이썬을 다시 정리하며, 나의 약점을 정리하고자 한다.

## 1. 리스트 순회 (정확히는 리스트를 활용한 데이터의 비교)

- 파이썬을 공부하기에 앞서 프로그래밍 기초에서도 이 부분을 해결하려는 로직에 대한 두뇌속 사고가 아직 자연스럽지가 않다는걸 많이 느낌.

```python

    list = [1,1,1,3,2,4,5,6,7,3,7,6,2]
  #와 같은 예시가 있다. 해당 리스트의 중복되지 않은 수만 출력하는 함수를 작성하시오.

  #사실 별다른 방도가 생각이 안나서 결국
    my_list = [s for s in input().split()]

    for i in my_list:
      if my_list.count(i) == 1: #카운트 함수로 품
        print (i)

  #아래는 모델 솔루션이고,
    my_list       = [s for s in input().split()]
    current_index = 0

    for element in my_list:
      is_unique = True
      list_without_current_element = my_list[0:current_index] + my_list[current_index+1:]

      for element2 in list_without_current_element:
        if element == element2:
          is_unique = False
          break

      if is_unique:
        print(element)

      current_index += 1
```

- 위와 같은 문제를 푸는 것과 같은 부분에는 다양한 방법이 있으나, 메소드를 쓰면 간단히 풀수 있으나, 메소드를 제약하고 순수하게 문제를 해결하는 부분에 대해서는 아직 갈길이 멀다라고 좌절함.

## 2. Function parameter

- 해당 문제는 포지셔널 파라미터 와 키워드 파라미터에 대한 이해를 시작으로, 파라미터에 디폴트 밸류를 설정시의 주의할 점이
  정리 되어야 했다.
  포지셔널 파라미터는 말그대로 순서대로 들어와야 하며, 키워드 파라미터는 인자의 이름을 따라가서 위치에 영향을 받지 않는다.
  하지만, 함수에 넘길때 디폴트 밸류를 앞에 인자에만 넘기면 문법적인 오류가 나게 되는데.

```python
def function(example1 = '아이유', example2):
    print(f"{example1} loves {example2}")
```

와 같이 함수가 선언되고 인자를 한개만 넘기게 되면, 당연히 우리는 기본인자가 들어있는 example1을 지나치고 example2에
할당될것 같지만, 인자는 순서대로 전달되기 때문에, 키워드, 포지션 상관없이 디폴트 밸류의 선언을 앞에 했다면, 뒤에도 해줘야하며, 그렇게 하지않으면, 함수가 호출될 시에 인자 전달을 할때 어디에 해야할지 알 수 없어 에러가 나게 된다.

## 3. Decorator

- 데코레이터는 파이썬 장고를 쓰면서 흔하게 접할수 있는데 바로 데코레이터 모듈을 써서 처리하는 과정들이 있는데,
  별 다른 생각없이 하나의 방식으로 이해하고 사용하다가, 직접 구현을 해보니. 뿌리 깊은 이해를 할 수 있었다.

  데코레이터의 역할은 단순하게 접근하면, 특정 함수의 실행 전에 먼저 수행하여, 함수의 실행 전 후에 추가적인 동작
  을 할수 있게 해주는 역할을 해주는 함수하고 생각할 수 있다. 하지만 머리로 이해하는 것과 실제 실행은 너무도
  달랐기 때문에 온몸으로 부딪쳐서 이해해본 결과. 다음과 같은 결론을 얻었다.

  데코레이터는 함수이지만, 직접적인 실행이 아닌 내부함수(클로저)를 통해서만 실행이 된다.
  따라서 실행하려는 로직은 단순히 함수로만 생각하기보다는 처리가 되는 순서에 대해 잘 생각을 해봐야 했다.
  검색을 통해 알 수 있는 부분은 기본적으로 @example과 같은 메인 함수 위에 적용한 데코레이터(장식자)를
  붙이게 되면, 데코레이터는 함수를 로드하여 정해진 로직을 통해(내부함수 안에서)이루어진 리턴을 반영하고 이후
  메인함수를 실행한다.

  단순히 함수를 넘겨 처리하는 부분은 금방 이해가 갔으나, 인자를 하나 받아 넘기는 데코레이터의 경우 다양한 궁금증이 생길 수 밖에 없었는데. 이유는 이러한 예제는 찾기가 어렵기도 했고, 찾았다고 해도 바로 이해하기는 어려움이 있었다.

  먼저 데코레이터는 기본적으로 선언된 함수를 강제로 받아 넘기기 때문에 당연히 넘어오게 되어 있지만, 어떻게 받아서
  일차적으로 받지 않으면 어떻게 해야할지 이해가 어려웠는데, 많은 시행착오 끝에 함수와 매개변수를 처리하려면,
  최종적인 함수 수행의 처리는 가장 마지막에 이루어져야하고, 인자를 받아서 넘기기 위해 우선적으로 인자를 받고, 이후에 함수를 받고, 이후의 내부함수에서 함수 및 인자의 가공이 가능하다는 것을 확실하게 인식하게 되었다.

  처음에는 떨어지는 에러코드를 처리해가며, 어떻게 해야 해결이 가능한지에만 급급했지만, 그로인해 넘어오지 않는 인자를
  어떻게든 받아보려고, \*args, \*\*kwargs(쓰지도 않음) 등을 넣어서 넘기기도 하고, 함수가 받아졌으나, 담기지 않아
  바로 넘기니 메모리 주소가 반환되기도 하고, 다양한 실패경험 후 원하는 작업이 이루어져야 할 단계 및 순서를 명확하게 이해할 수 있었다.

  말로만 정리를 해서 코드적으로 이해가 다가오지 않을수 있으니, 이후에는 새로운 데코레이터 예제를 생성하여, 다시 기술하겠다.

  ```python
  def name_decorator(param):
    def wrapper(func):
        def inner():
            message = func()
            return message+param
        return inner
    return wrapper

  @name_decorator("name")
  def greeting():

    return "Hello, "
  ```

## 4. Dictionary의 성질 이해.

- 딕셔너리는 단순히 키:밸류로 이루어진 (HashMap)자료형으로 생각했으나, 이에 대한 생성 및 삭제에 대해서는 잘
  정리하지 못 했던 것 같다.
  딕셔너리의 할당의 순서는 먼저 빈 {}를 변수에 할당. 이후 변수명["키"] = 밸류 의 순서로 할당된다.
  네스티드 될 때에도 바로 주입이 아닌 키에 {} 공간 할당 후 다시 키를 대입하여 새로운 뎁스로 할당이 가능하다.
  문제는 언제나, 익숙하다고 아는 척이나 하고, 실제로 사용하려고 하면 자료를 찾아보고 있는 모습이다.
  삭제는 del 이나 .pop() 등이 있다.
  검색은 키로 가능하고, 밸류로도 가능하다.
  보통 데이터의 여부는 in, not in, .get() 등으로 확인 가능하다.

## 각 자료형 별 컴프리헨션

- 이 부분은 아직 수업으로는 진행하지 못했지만, 별도로 정리하려고 한다.
  기본적으로 시퀀스 자료형이면서 수정이 가능한 리스트와 딕셔너리로 진행한다.
